<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Crop Analysis System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    

    <style>
        
        :root {
            --primary-green: #2B593F;
            --secondary-green: #7AB893;
            --accent-yellow: #FFD700;
            --pure-white: #FFFFFF;
            --light-bg: #F5FEF9;
            --danger-red: #E74C3C;
            --warning-orange: #E67E22;
            --info-blue: #3498DB;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: var(--light-bg);
            margin: 0;
            padding: 20px;
            color: var(--primary-green);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, var(--primary-green), var(--secondary-green));
            color: var(--pure-white);
            border-radius: 20px;
            margin-bottom: 2rem;
            animation: slideIn 1s ease;
            box-shadow: 0 8px 24px rgba(42,89,63,0.1);
        }

        .stage {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
        }

        .active-stage {
            display: block;
        }

        .upload-section {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .input-section {
            background: var(--pure-white);
            padding: 2rem;
            border-radius: 20px;
            box-shadow: 0 8px 24px rgba(42,89,63,0.1);
            flex: 1;
            min-width: 300px;
            transition: transform 0.3s ease;
        }

        .input-section:hover {
            transform: translateY(-5px);
        }

        .file-upload {
            background: #F5FEF9;
            border: 2px dashed var(--primary-green);
            padding: 2rem;
            text-align: center;
            border-radius: 15px;
            margin-bottom: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload:hover {
            background: var(--accent-yellow);
            border-color: var(--primary-green);
            transform: scale(1.02);
        }

        #webcam-container, #webcam-container-stage1 {
            margin: 1rem auto;
            border: 3px solid var(--primary-green);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(42,89,63,0.2);
            width: 400px;
            height: 400px;
        }

        .results-section {
            background: var(--pure-white);
            padding: 2rem;
            border-radius: 20px;
            box-shadow: 0 8px 24px rgba(42,89,63,0.1);
            flex: 1;
            min-width: 300px;
            animation: fadeIn 1s ease;
        }

        .result-item {
            padding: 1.5rem;
            margin: 1rem 0;
            background: #F5FEF9;
            border-radius: 12px;
            transition: all 0.3s ease;
            animation: popIn 0.5s ease;
        }

        .result-item:hover {
            transform: translateX(10px);
            background: var(--primary-green);
            color: var(--pure-white);
            box-shadow: 0 4px 12px rgba(42,89,63,0.1);
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .sensor-card {
            text-align: center;
            padding: 1.5rem;
            background: var(--light-bg);
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
        }

        .sensor-card.npk {
            background: #ffe100;
        }

        .sensor-card.ph {
            background: #FFD3B6;
        }

        .sensor-card.moisture {
            background: #A8E6CF;
        }

        .sensor-card:hover {
            transform: scale(1.05);
        }

        .sensor-card.npk:hover {
            background: var(--primary-green);
            color: white;
        }

        .sensor-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .sensor-status {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            background: var(--pure-white);
        }

        .status-optimal {
            color: var(--primary-green);
        }

        .status-warning {
            color: var(--warning-orange);
        }

        .status-danger {
            color: var(--danger-red);
        }

        .ai-analysis {
            background: #FFFBE6;
            padding: 1.5rem;
            border-radius: 15px;
            margin-top: 2rem;
            border-left: 4px solid var(--primary-green);
            animation: fadeInUp 0.8s ease;
        }

        button {
            background: var(--primary-green);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            margin: 0.5rem 0;
        }

        button:hover {
            background: var(--accent-yellow);
            color: var(--primary-green);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42,89,63,0.2);
        }

        progress {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: #E0F0E9;
        }

        progress::-webkit-progress-bar { background: #E0F0E9; border-radius: 6px; }
        progress::-webkit-progress-value { 
            background: var(--accent-yellow);
            border-radius: 6px;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            80% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes fadeInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .medicine-list a {
            color: var(--primary-green);
            text-decoration: none;
            font-weight: 600;
            position: relative;
        }

        .medicine-list a:after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--accent-yellow);
            transition: width 0.3s ease;
        }

        .medicine-list a:hover:after {
            width: 100%;
        }

        .loader {
            border: 4px solid #E0F0E9;
            border-top: 4px solid var(--accent-yellow);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        .typewriter {
            border-right: 2px solid var(--primary-green);
            white-space: pre-wrap;
            overflow: hidden;
            font-family: monospace;
            animation: typing 3s steps(40, end), blink-caret 0.75s step-end infinite;
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: var(--primary-green); }
        }

        .treatment-section {
            margin: 1.5rem 0;
            padding: 1rem;
            background: #F5FEF9;
            border-radius: 12px;
        }

        .medicine-recommendations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .medicine-card {
            padding: 1rem;
            background: var(--pure-white);
            border-radius: 8px;
            border: 1px solid var(--secondary-green);
            transition: all 0.3s ease;
        }

        .medicine-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(242, 255, 0, 0.1);
        }

        .price {
            font-weight: bold;
            color: var(--primary-green);
            margin-top: 0.5rem;
        }

        .sensor-chart {
            width: 100%;
            height: 200px;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            .upload-section {
                flex-direction: column;
            }
            
            .input-section, .results-section {
                min-width: 100%;
            }
            
            #webcam-container, #webcam-container-stage1 {
                width: 100%;
                height: auto;
            }
        }

        .treatment-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .organic-box {
            background: #E8F5E9;
            padding: 1.5rem;
            border-radius: 15px;
            border-left: 4px solid #4CAF50;
        }
        
        .chemical-box {
            background: #FFEBEE;
            padding: 1.5rem;
            border-radius: 15px;
            border-left: 4px solid #F44336;
        }
        
        .conclusion-box {
            background: #FFF3E0;
            padding: 1.5rem;
            border-radius: 15px;
            margin-top: 2rem;
            border-left: 4px solid #FFA726;
        }
        
        .analysis-section {
            background: var(--pure-white);
            padding: 1.5rem;
            border-radius: 15px;
            margin: 1rem 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        
        .treatment-columns ul {
            padding-left: 1.5rem;
            margin: 1rem 0;
        }
        
        .treatment-columns li {
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
        }/* Climate Data Display Styles */
.climate-section {
    margin: 20px 0;
    background: #f8f9fa;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}

.climate-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.climate-header h2 {
    margin: 0;
    color: #2c3e50;
    font-size: 1.5rem;
}

.climate-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.climate-card {
    background: white;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    transition: transform 0.2s, box-shadow 0.2s;
}

.climate-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.climate-card h3 {
    margin-top: 0;
    color: #3498db;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.climate-card h3 i {
    font-size: 1.2rem;
}

.climate-value {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
    margin: 10px 0;
}

.climate-unit {
    color: #7f8c8d;
    font-size: 0.9rem;
}

.climate-trend {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9rem;
    color: #7f8c8d;
}

.trend-up {
    color: #e74c3c;
}

.trend-down {
    color: #2ecc71;
}

.climate-history {
    margin-top: 20px;
}

.history-chart {
    height: 200px;
    background: white;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.tab-container {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}

.tab {
    padding: 8px 15px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
}

.tab.active {
    border-bottom: 2px solid #3498db;
    color: #3498db;
    font-weight: bold;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.weather-icon-large {
    width: 60px;
    height: 60px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .climate-cards {
        grid-template-columns: 1fr;
    }
    
    .climate-value {
        font-size: 1.8rem;
    }
}/* Medicine Recommendations Container */
.medicine-container {
    margin: 2rem 0;
    width: 100%;
}

.medicine-container h3 {
    color: #2c3e50;
    font-size: 1.5rem;
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid #ecf0f1;
}

/* Medicine Grid - Flexbox Version */
.medicine-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    justify-content: center;
}

/* Medicine Card Styling */
.medicine-card {
    flex: 1 1 300px; /* Flex-grow, flex-shrink, flex-basis */
    max-width: 400px;
    min-width: 280px;
    background: white;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
}

.medicine-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

/* Card Header */
.medicine-header {
    padding: 1rem;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #dee2e6;
}

.medicine-header h4 {
    margin: 0;
    font-size: 1.1rem;
    color: #2c3e50;
    flex: 1;
}

.medicine-type {
    padding: 0.25rem 0.5rem;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: bold;
    text-transform: uppercase;
    margin-left: 0.5rem;
}

.medicine-type.chemical {
    background: #ffebee;
    color: #c62828;
}

.medicine-type.organic {
    background: #e8f5e9;
    color: #2e7d32;
}

/* Card Body */
.medicine-details {
    padding: 1.25rem;
    flex: 1;
    display: flex;
    flex-direction: column;
}

.medicine-details p {
    margin: 0 0 1rem 0;
    color: #495057;
    line-height: 1.5;
    flex: 1;
}

.medicine-specs {
    margin-top: 1rem;
    font-size: 0.9rem;
    color: #6c757d;
}

.medicine-specs div {
    margin-bottom: 0.5rem;
    display: flex;
    align-items: flex-start;
}

.medicine-specs i {
    margin-right: 0.5rem;
    color: #3498db;
    min-width: 20px;
    text-align: center;
}

/* Card Footer */
.medicine-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1.25rem;
    border-top: 1px solid #e9ecef;
    background-color: #f8f9fa;
}

.medicine-price {
    font-weight: bold;
    color: #2e7d32;
    font-size: 0.95rem;
}

.buy-button {
    background: #4285f4;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background 0.2s;
}

.buy-button:hover {
    background: #3367d6;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    .medicine-grid {
        gap: 1rem;
    }
    
    .medicine-card {
        flex: 1 1 100%;
        max-width: 100%;
    }
}

@media (max-width: 480px) {
    .medicine-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .medicine-type {
        margin: 0.5rem 0 0 0;
        align-self: flex-start;
    }
    
    .medicine-footer {
        flex-direction: column;
        gap: 0.75rem;
        align-items: flex-start;
    }
    
    .buy-button {
        width: 100%;
        justify-content: center;
    }
}
    </style>
</head>
<body><div id="google_translate_element"></div>

    <!-- First Stage - Leaf Detection -->
    <div id="first-stage" class="stage active-stage">
        <div class="header">
            <h1><i class="fas fa-leaf"></i> Leaf Detection System</h1>
            <p>Use webcam or upload image to verify plant leaf</p>
        </div>

        <div class="upload-section">
            <div class="input-section">
                <button onclick="initWebcamStage1()">
                    <i class="fas fa-camera"></i> Use Webcam
                </button>
                <div id="webcam-container-stage1"></div>
            </div>

            <div class="input-section">
                <div class="file-upload" onclick="document.getElementById('file-input-stage1').click()">
                    <i class="fas fa-upload fa-2x"></i>
                    <h3>Click to Upload Image</h3>
                    <p>Supported formats: JPG, PNG, JPEG</p>
                    <input type="file" id="file-input-stage1" accept="image/*" hidden 
                           onchange="handleStage1Upload(event)">
                </div>
                <img id="upload-preview" alt="Preview" style="display: none; max-width: 100%; margin-top: 1rem;">
            </div>
        </div>

        <div id="label-container-stage1" class="result-item" style="margin-top: 2rem;"></div>
    </div>

    <!-- Second Stage - Crop Health Analysis -->
    <div id="second-stage" class="stage">
        <div class="container">
            <div class="header">
                <h1><i class="fas fa-seedling"></i> Advanced Crop Health Analyzer</h1>
                <p>Upload plant image or use webcam to analyze crop health with soil sensor data</p>
            </div>
    
            <div class="content-wrapper">
                <div class="input-section">
                    <button onclick="initWebcam()">
                        <i class="fas fa-camera"></i> Start Webcam
                    </button>
                    <div id="webcam-container"></div>
    
                    <div class="file-upload" onclick="document.getElementById('file-input').click()">
                        <i class="fas fa-upload fa-2x"></i>
                        <h3>Click to Upload Plant Image</h3>
                        <p>Supported formats: JPG, PNG, JPEG</p>
                        <input type="file" id="file-input" accept="image/*" hidden 
                               onchange="handleImageUpload(event)">
                    </div>
                    <img id="preview-image" alt="Preview" style="display:none; max-width: 100%; margin-top: 1rem;">
                </div>
    
                <div class="results-section">
                    <h2><i class="fas fa-chart-bar"></i> Analysis Results</h2>
                    <div id="label-container"></div>
                    
                    <h3><i class="fas fa-tachometer-alt"></i> Soil Sensor Data</h3>
                    <div class="sensor-grid" id="sensor-container"></div>
                     <!-- Add this HTML where you want the climate data to appear -->
     <div id="climate-container"></div>
                    <div class="ai-analysis">
                        <h3><i class="fas fa-brain"></i> AI Recommendations</h3>
                        <div class="loader" id="ai-loader"></div>
                        <div id="ai-analysis-content"></div>
                        <div id="medicine-recommendations-container" class="medicine-container">
                            <h3>Recommended Treatments</h3>
                            <div id="medicine-recommendations" class="medicine-grid"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>    
 
<script type="text/javascript">
  function googleTranslateElementInit() {
    new google.translate.TranslateElement(
      {
        pageLanguage: 'en',
        includedLanguages: 'ta,en',
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      },
      'google_translate_element'
    );
  }
</script>

<script type="text/javascript"
  src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit">
</script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script>
        // Configuration
        const TM_MODEL_URL_STAGE1 = "https://teachablemachine.withgoogle.com/models/35GeiC0Ms/";
        const TM_MODEL_URL = "https://teachablemachine.withgoogle.com/models/zI1G9a6ee/";
        const THINGSPEAK_API = "https://api.thingspeak.com/channels/2828170/feeds.json?api_key=R7NLLQNPWE6V6RX7&results=1";
        const GEMINI_API_KEY = "AIzaSyA_YmmMgnjpwFsp756Mba9VbK5a-lQb5cA";
        const WEATHER_API_KEY = '647e990dc0844e65a63102000251103';
        const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
        
        // Global variables
        let stage1Model, stage1Webcam;
        let model, webcam;
        let weatherData = null;
        let historicalClimateData = null;
        
        // First Stage Functions - Remain unchanged
        async function initWebcamStage1() {
            try {
                const modelURL = TM_MODEL_URL_STAGE1 + "model.json";
                const metadataURL = TM_MODEL_URL_STAGE1 + "metadata.json";
                
                stage1Model = await tmImage.load(modelURL, metadataURL);
                stage1Webcam = new tmImage.Webcam(400, 400, true);
                
                await stage1Webcam.setup();
                await stage1Webcam.play();
                
                document.getElementById('webcam-container-stage1').appendChild(stage1Webcam.canvas);
                webcamLoopStage1();
            } catch (error) {
                console.error('Webcam Error:', error);
                alert('Error accessing webcam. Please check permissions.');
            }
        }
    
        async function webcamLoopStage1() {
            stage1Webcam.update();
            const predictions = await stage1Model.predict(stage1Webcam.canvas);
            handleStage1Prediction(predictions);
            requestAnimationFrame(webcamLoopStage1);
        }
    
        async function handleStage1Upload(event) {
            const file = event.target.files[0];
            if (!file) return;
    
            const reader = new FileReader();
            reader.onload = async (e) => {
                const img = new Image();
                img.src = e.target.result;
                
                img.onload = async () => {
                    // Show preview
                    const preview = document.getElementById('upload-preview');
                    preview.src = img.src;
                    preview.style.display = 'block';
                    
                    // Load model if not already loaded
                    if (!stage1Model) {
                        const modelURL = TM_MODEL_URL_STAGE1 + "model.json";
                        const metadataURL = TM_MODEL_URL_STAGE1 + "metadata.json";
                        stage1Model = await tmImage.load(modelURL, metadataURL);
                    }
                    
                    // Make prediction
                    const predictions = await stage1Model.predict(img);
                    handleStage1Prediction(predictions);
                };
            };
            reader.readAsDataURL(file);
        }
    
        function handleStage1Prediction(predictions) {
            const container = document.getElementById('label-container-stage1');
            const topPrediction = predictions.reduce((max, current) => 
                (current.probability > max.probability) ? current : max);
            
            container.innerHTML = `
                <div class="result-item">
                    <strong>${topPrediction.className}</strong>
                    <progress value="${topPrediction.probability}" max="1"></progress>
                    ${(topPrediction.probability * 100).toFixed(1)}%
                </div>
            `;
    
            if(topPrediction.className.toLowerCase() === 'others') {
                window.location.href = 'http://127.0.0.1:5000/index/role/main/error';
                return;
            }
    
            if(topPrediction.className.toLowerCase() === 'plant') {
                // Switch to second stage after short delay
                setTimeout(() => {
                    document.getElementById('first-stage').classList.remove('active-stage');
                    document.getElementById('second-stage').classList.add('active-stage');
                    initCropAnalysis();
                }, 1500);
            }
        }
    
        // Second Stage Functions - Modified for better Gemini response and medicine display
        async function initModel() {
            model = await tmImage.load(TM_MODEL_URL + "model.json", TM_MODEL_URL + "metadata.json");
        }
    
        async function initWebcam() {
            await initModel();
            webcam = new tmImage.Webcam(400, 400, true);
            await webcam.setup();
            await webcam.play();
            document.getElementById('webcam-container').appendChild(webcam.canvas);
            webcamLoop();
        }
    
        async function webcamLoop() {
            webcam.update();
            await predict(webcam.canvas);
            requestAnimationFrame(webcamLoop);
        }
    
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
    
            const reader = new FileReader();
            reader.onload = async (e) => {
                const img = new Image();
                img.src = e.target.result;
                img.onload = async () => {
                    document.getElementById('preview-image').style.display = 'block';
                    document.getElementById('preview-image').src = img.src;
                    await initModel();
                    await predict(img);
                };
            };
            reader.readAsDataURL(file);
        }
   async function predict(imageElement) {
    try {
        // 1. Make prediction
        const predictions = await model.predict(imageElement);
        displayPredictions(predictions);
        
        // 2. Get the highest probability disease
        const detectedDisease = predictions[0].className;

        // 3. Retrieve location data from local storage
        const district = localStorage.getItem('district') || 'Unknown';
        const village = localStorage.getItem('village') || 'Unknown';
        const plantName = localStorage.getItem('plantName') || 'Unknown';

        // 4. Get current time
        const currentTime = new Date().toISOString();

        // 5. Save prediction data to server
        const predictionData = {
            district,
            village,
            plantName,
            disease: detectedDisease,
            time: currentTime
        };

        const saveResponse = await fetch('save_data.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(predictionData)
        });

        if (!saveResponse.ok) {
            console.error('Failed to save data to server');
        }

        // 6. Fetch Sensor Data
        const sensorData = await fetchSensorData();
        displaySensorData(sensorData);
        
        // 7. Fetch Weather Data (if district available)
        if (district !== 'Unknown') {
            await fetchWeatherData(district);
        }

        // 8. Get AI analysis (only if we have sensor data)
        let analysis = null;
        if (sensorData) {
            analysis = await getGeminiAnalysis(detectedDisease, sensorData);
            displayAnalysis(analysis, detectedDisease);
        }

        // 9. Save all data locally
        const savedData = await saveFarmData();
        
        // 10. Verify saved data
        checkFarmData();

        // 11. Send data to Flask endpoint (non-blocking)
        sendDataToFlask().catch(e => console.error('Background send to Flask failed:', e));
        
        // 12. Retry any previously failed submissions
        retryFailedSubmissions().catch(e => console.error('Retry of failed submissions failed:', e));

        // 13. Return all collected data
        return {
            predictions,
            sensorData,
            weatherData: this.weatherData,
            historicalClimateData: this.historicalClimateData,
            aiAnalysis: analysis,
            savedData
        };

    } catch (error) {
        console.error('Prediction Error:', error);
        
        // Attempt to save partial data if error occurs
        try {
            await saveFarmData();
            checkFarmData();
        } catch (saveError) {
            console.error('Data saving failed:', saveError);
        }
        
        throw error;
    }
}
// Enhanced saveFarmData() with verification
async function saveFarmData() {
    // Verify all required elements exist
    const verifyElement = (selector) => {
        const el = document.querySelector(selector);
        if (!el) console.error(`Element not found: ${selector}`);
        return el;
    };

    // Get all required elements
    const diseaseEl = verifyElement('#label-container .result-item strong');
    const nEl = verifyElement('.npk:nth-child(1) .sensor-value');
    const pEl = verifyElement('.npk:nth-child(2) .sensor-value');
    const kEl = verifyElement('.npk:nth-child(3) .sensor-value');
    const phEl = verifyElement('.ph .sensor-value');
    const moistureEl = verifyElement('.moisture .sensor-value');

    // Create data object
    const farmData = {
        timestamp: new Date().toISOString(),
        field: localStorage.getItem('fieldValue') || 'Unknown',
        plant: localStorage.getItem('plantName') || 'Unknown',
        disease: diseaseEl?.textContent || 'Unknown',
        soil: {
            nitrogen: nEl ? parseFloat(nEl.textContent) || 0 : 0,
            phosphorus: pEl ? parseFloat(pEl.textContent) || 0 : 0,
            potassium: kEl ? parseFloat(kEl.textContent) || 0 : 0,
            ph: phEl ? parseFloat(phEl.textContent) || 0 : 0,
            moisture: moistureEl ? parseFloat(moistureEl.textContent) || 0 : 0
        },
        weather: this.weatherData || null,
        historicalClimate: this.historicalClimateData || null
    };

    // Save to localStorage
    let history = JSON.parse(localStorage.getItem('farmHistory')) || [];
    history.push(farmData);
    localStorage.setItem('farmHistory', JSON.stringify(history));
    
    console.log('Data saved successfully:', farmData);
    return farmData;
}

// Enhanced checkFarmData()
function checkFarmData() {
    const history = JSON.parse(localStorage.getItem('farmHistory')) || [];
    
    if (history.length === 0) {
        console.log('%cNo farm data found in storage', 'color: red; font-weight: bold;');
        return;
    }

    console.log('%c=== FARM DATA VERIFICATION ===', 'color: green; font-weight: bold;');
    
    history.forEach((entry, index) => {
        console.groupCollapsed(`%cEntry #${index + 1} - ${new Date(entry.timestamp).toLocaleString()}`, 'color: blue;');
        
        // Basic info
        console.table({
            'Field': entry.field,
            'Plant': entry.plant,
            'Disease': entry.disease
        });

        // Soil data
        console.table({
            'Nitrogen (ppm)': entry.soil.nitrogen,
            'Phosphorus (ppm)': entry.soil.phosphorus,
            'Potassium (ppm)': entry.soil.potassium,
            'pH Level': entry.soil.ph,
            'Moisture (%)': entry.soil.moisture
        });

        // Weather data
        if (entry.weather) {
            console.table({
                'Temperature (¬∞C)': entry.weather.temp_c,
                'Humidity (%)': entry.weather.humidity,
                'Precipitation (mm)': entry.weather.precip_mm,
                'Wind (kph)': entry.weather.wind_kph
            });
        }

        console.groupEnd();
    });

    console.log('%cRaw data for debugging:', 'font-weight: bold;', history);
}
    
        function displayPredictions(predictions) {
            const container = document.getElementById('label-container');
            container.innerHTML = predictions.sort((a, b) => b.probability - a.probability)
                .map(p => `
                    <div class="result-item">
                        <strong>${p.className}</strong>
                        <progress value="${p.probability}" max="1"></progress>
                        ${(p.probability * 100).toFixed(1)}%
                    </div>
                `).join('');
        }
    
        async function fetchSensorData() {
            try {
                const response = await fetch(THINGSPEAK_API);
                const data = await response.json();
                if (data && data.feeds && data.feeds.length > 0) {
                    return {
                        nitrogen: parseFloat(data.feeds[0].field1),
                        phosphorus: parseFloat(data.feeds[0].field2),
                        potassium: parseFloat(data.feeds[0].field3),
                        ph: parseFloat(data.feeds[0].field4),
                        moisture: parseFloat(data.feeds[0].field5),
                        timestamp: data.feeds[0].created_at
                    };
                }
                return null;
            } catch (error) {
                console.error('Sensor Data Error:', error);
                return null;
            }
        }
    
        async function fetchWeatherData(location) {
            try {
                // Fetch current weather
                const weatherResponse = await fetch(
                    `https://api.weatherapi.com/v1/current.json?key=${WEATHER_API_KEY}&q=${location}&aqi=no`
                );
                const weatherData = await weatherResponse.json();
                
                if (weatherData.error) {
                    console.error('Weather API Error:', weatherData.error.message);
                    return;
                }
                
                // Store current weather data
                this.weatherData = weatherData.current;
                
                // Fetch historical climate data
                const { lat, lon } = weatherData.location;
                const endDate = new Date();
                const startDate = new Date();
                startDate.setMonth(endDate.getMonth() - 6);
                
                const formatDate = (date) => date.toISOString().split('T')[0];
                
                const historicalResponse = await fetch(
                    `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${formatDate(startDate)}&end_date=${formatDate(endDate)}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,relative_humidity_2m_mean&timezone=auto`
                );
                const historicalData = await historicalResponse.json();
                
                if (historicalData.error) {
                    console.error('Historical Climate API Error:', historicalData.error.message);
                    return;
                }
                
                // Store historical climate data
                this.historicalClimateData = historicalData.daily;
                
                // Display weather information
                displayWeatherData(weatherData);
                
            } catch (error) {
                console.error('Error fetching weather data:', error);
            }
        }
    
        function displayWeatherData(data) {
            const { location, current } = data;
            const localTime = new Date(location.localtime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const localDate = new Date(location.localtime).toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
    
            const weatherContainer = document.getElementById('weather-container');
            weatherContainer.innerHTML = `
                <div class="weather-card">
                    <div class="main-info">
                        <div class="location">
                            <h3>Current Weather in ${location.name}</h3>
                            <p>${localDate} ‚Ä¢ ${localTime}</p>
                        </div>
                        <div class="weather-details">
                            <div class="temperature">${Math.round(current.temp_c)}¬∞C</div>
                            <img class="weather-icon" src="${current.condition.icon.replace('64x64', '128x128')}" alt="${current.condition.text}">
                            <p class="condition-text">${current.condition.text}</p>
                        </div>
                    </div>
                    <div class="weather-stats">
                        <div><i class="fas fa-tint"></i> Humidity: ${current.humidity}%</div>
                        <div><i class="fas fa-wind"></i> Wind: ${current.wind_kph} km/h ${current.wind_dir}</div>
                        <div><i class="fas fa-cloud-rain"></i> Precipitation: ${current.precip_mm} mm</div>
                        <div><i class="fas fa-sun"></i> UV Index: ${current.uv}</div>
                    </div>
                </div>
            `;
        }
    
     let lastData = null; // store last displayed data

async function fetchAndCalibrateData() {
    const url = "https://api.thingspeak.com/channels/2828170/feeds.json?api_key=R7NLLQNPWE6V6RX7&results=1";
    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.feeds.length > 0) {
            const latestEntry = data.feeds[0];

            // Get raw sensor values
            const rawN = parseFloat(latestEntry.field1) || 0;
            const rawP = parseFloat(latestEntry.field2) || 0;
            const rawK = parseFloat(latestEntry.field3) || 0;
            const rawPH = parseFloat(latestEntry.field4) || 0;
            const rawMoisture = parseFloat(latestEntry.field5) || 0;

            // Apply calibration
            const calibratedData = {
                nitrogen: Math.round(rawN * 15 * 100) / 100,
                phosphorus: Math.round(rawP * 1 * 100) / 100,
                potassium: Math.round(rawK * 3.5 * 100) / 100,
                ph: Math.round(rawPH * 100) / 100,
                moisture: Math.round(rawMoisture * 100) / 100
            };

            // Only update if data changed
            if (JSON.stringify(calibratedData) !== JSON.stringify(lastData)) {
                lastData = calibratedData;
                displaySensorData(calibratedData);
            }
        } else {
            displaySensorData(null);
        }
    } catch (error) {
        console.error("Error fetching or calibrating data:", error);
        displaySensorData(null);
    }
}

function displaySensorData(data) {
    const container = document.getElementById('sensor-container');
    if (!data) {
        container.innerHTML = '<div class="result-item">‚ö†Ô∏è Sensor Data Unavailable</div>';
        return;
    }

    const nitrogenStatus = getNitrogenStatus(data.nitrogen);
    const phosphorusStatus = getPhosphorusStatus(data.phosphorus);
    const potassiumStatus = getPotassiumStatus(data.potassium);
    const phStatus = getPHStatus(data.ph);
    const moistureStatus = getMoistureStatus(data.moisture);

    container.innerHTML = `
        <div class="sensor-card npk">
            <div class="sensor-status ${nitrogenStatus.class}">${nitrogenStatus.text}</div>
            <h4><i class="fas fa-leaf"></i> Nitrogen</h4>
            <div class="sensor-value notranslate">${data.nitrogen.toFixed(1)}</div>
            <small>ppm</small>
            <div class="sensor-range">Optimal: 140.5 - 280 ppm</div>
        </div>
        <div class="sensor-card npk">
            <div class="sensor-status ${phosphorusStatus.class}">${phosphorusStatus.text}</div>
            <h4><i class="fas fa-atom"></i> Phosphorus</h4>
            <div class="sensor-value notranslate">${data.phosphorus.toFixed(1)}</div>
            <small>ppm</small>
            <div class="sensor-range">Optimal: 7.05 - 14 ppm</div>
        </div>
        <div class="sensor-card npk">
            <div class="sensor-status ${potassiumStatus.class}">${potassiumStatus.text}</div>
            <h4><i class="fas fa-bolt"></i> Potassium</h4>
            <div class="sensor-value notranslate">${data.potassium.toFixed(1)}</div>
            <small>ppm</small>
            <div class="sensor-range">Optimal: 75.5 - 125 ppm</div>
        </div>
        <div class="sensor-card ph">
            <div class="sensor-status ${phStatus.class}">${phStatus.text}</div>
            <h4><i class="fas fa-flask"></i> pH Level</h4>
            <div class="sensor-value notranslate">${data.ph.toFixed(1)}</div>
            <small>pH</small>
            <div class="sensor-range">Optimal: 5.5-7.0</div>
        </div>
        <div class="sensor-card moisture">
            <div class="sensor-status ${moistureStatus.class}">${moistureStatus.text}</div>
            <h4><i class="fas fa-tint"></i> Moisture</h4>
            <div class="sensor-value notranslate">${data.moisture.toFixed(1)}</div>
            <small>%</small>
            <div class="sensor-range">Optimal: 40-70%</div>
        </div>
    `;
}

// Status functions remain unchanged
function getNitrogenStatus(value) {
    if (value < 70) return { text: 'Very Low', class: 'status-danger' };
    if (value <= 140) return { text: 'Low', class: 'status-warning' };
    if (value <= 210) return { text: 'Medium', class: 'status-optimal' };
    if (value <= 280) return { text: 'Moderately High', class: 'status-optimal' };
    if (value <= 350) return { text: 'High', class: 'status-warning' };
    return { text: 'Very High', class: 'status-danger' };
}

function getPhosphorusStatus(value) {
    if (value < 3.5) return { text: 'Very Low', class: 'status-danger' };
    if (value <= 7) return { text: 'Low', class: 'status-warning' };
    if (value <= 10.5) return { text: 'Medium', class: 'status-optimal' };
    if (value <= 14) return { text: 'Moderately High', class: 'status-optimal' };
    if (value <= 17.5) return { text: 'High', class: 'status-warning' };
    return { text: 'Very High', class: 'status-danger' };
}

function getPotassiumStatus(value) {
    if (value < 50) return { text: 'Very Low', class: 'status-danger' };
    if (value <= 75) return { text: 'Low', class: 'status-warning' };
    if (value <= 100) return { text: 'Medium', class: 'status-optimal' };
    if (value <= 125) return { text: 'Moderately High', class: 'status-optimal' };
    if (value <= 150) return { text: 'High', class: 'status-warning' };
    return { text: 'Very High', class: 'status-danger' };
}

function getPHStatus(value) {
    if (value < 5.5) return { text: 'Acidic', class: 'status-danger' };
    if (value <= 7.0) return { text: 'Optimal', class: 'status-optimal' };
    return { text: 'Alkaline', class: 'status-warning' };
}

function getMoistureStatus(value) {
    if (value < 40) return { text: 'Dry', class: 'status-warning' };
    if (value <= 70) return { text: 'Optimal', class: 'status-optimal' };
    return { text: 'Wet', class: 'status-warning' };
}

// Initial call and interval
fetchAndCalibrateData();
setInterval(fetchAndCalibrateData, 60000);
    
        async function getGeminiAnalysis(disease, sensorData) {
            const loader = document.getElementById('ai-loader');
            const content = document.getElementById('ai-analysis-content');
            
            loader.style.display = 'block';
            content.innerHTML = '';
    
            try {
                // Calculate climate averages from historical data
                let climateAnalysis = '';
                if (this.historicalClimateData) {
                    const { temperature_2m_max, temperature_2m_min, precipitation_sum, relative_humidity_2m_mean } = this.historicalClimateData;
                    
                    // Calculate averages
                    const avgMaxTemp = temperature_2m_max.reduce((a, b) => a + b, 0) / temperature_2m_max.length;
                    const avgMinTemp = temperature_2m_min.reduce((a, b) => a + b, 0) / temperature_2m_min.length;
                    const totalPrecip = precipitation_sum.reduce((a, b) => a + b, 0);
                    const avgHumidity = relative_humidity_2m_mean.reduce((a, b) => a + b, 0) / relative_humidity_2m_mean.length;
                    
                    climateAnalysis = `
                    üå¶Ô∏è Climate Analysis (Last 6 Months):
                    - Average High Temp: ${avgMaxTemp.toFixed(1)}¬∞C
                    - Average Low Temp: ${avgMinTemp.toFixed(1)}¬∞C
                    - Total Precipitation: ${totalPrecip.toFixed(1)} mm
                    - Average Humidity: ${avgHumidity.toFixed(1)}%
                    `;
                }
    
                const prompt = `  this is cottun plant for compleatly 
                Generate a detailed 500-word plant disease analysis with the structure below. Use visually appealing and context-specific emojis for each section header. Maintain single line spacing between paragraphs. Focus on the exact conditions provided:
                
               ü¶† DISEASE PROFILE  
üß¨ Exact identification of ${disease}  
üëÅÔ∏è Primary visual symptoms  
üìà Disease progression pattern  
üåø Most vulnerable plant parts  

üåæ SOIL ANALYSIS  
üå± Impact of current N: ${sensorData.nitrogen} mg/kg level  
üß™ Effect of P: ${sensorData.phosphorus} mg/kg availability  
üß≤ Role of K: ${sensorData.potassium} mg/kg balance  
‚öóÔ∏è Consequences of pH ${sensorData.ph}  
üíß Moisture level implications at ${sensorData.moisture}%  

üå§Ô∏è WEATHER CORRELATION  
üå°Ô∏è Disease spread under ${this.weatherData?.temp_c || '--'}¬∞C temps  
üí¶ Humidity impact at ${this.weatherData?.humidity || '--'}%  
üåßÔ∏è Rainfall influence (${this.weatherData?.precip_mm || '--'}mm)  
üå¨Ô∏è Wind patterns (${this.weatherData?.wind_kph || '--'} km/h ${this.weatherData?.wind_dir || ''})  
üîÜ UV index (${this.weatherData?.uv || '--'}) effects  

üßØ TREATMENT PLAN  
üö® Immediate containment actions  
ü™µ Soil amendment requirements  
üß¥ Foliar treatment approach  
‚è∞ Application timing advice  
üß§ Safety precautions  

üõ°Ô∏è PREVENTION PROTOCOL  
üîÑ Cultural practices needed  
üïµÔ∏è Monitoring schedule  
üçÉ Environmental modifications  
üåæ Resistant varieties recommendation  

üåø RECOVERY OUTLOOK  
‚è≥ Expected timeline  
üëÄ Visual improvement markers  
üìâ Yield impact projection  

                
                
                ===MEDICINE RECOMMENDATIONS===
               After analyzing the disease and environmental conditions, recommend specific treatments in the following JSON format. Consider:
- The specific disease (${disease})
- Current soil nutrient levels (N:${sensorData.nitrogen}, P:${sensorData.phosphorus}, K:${sensorData.potassium})
- Soil pH (${sensorData.ph})
- Moisture levels (${sensorData.moisture}%)
- Current weather conditions
- Whether organic or chemical treatments would be most appropriate

Provide 3-5 specific treatment recommendations in this exact JSON format:
{
    "medicines": [
        {
            "name": "Product Name",
            "type": "Chemical|Organic",
            "description": "How this treatment addresses the specific conditions",
            "dosage": "Specific dosage instructions",
            "frequency": "Application frequency",
            "price": "Approximate price range",
            "considerations": "Any special considerations based on current conditions"
        }
    ]
}

Important guidelines for medicine recommendations:
1. Recommend products that would be effective given the current soil pH
2. Adjust recommendations based on nutrient deficiencies/excesses
3. Consider moisture levels in application recommendations
4. Account for current weather conditions in timing suggestions
5. Include both chemical and organic options when available
6. Specify if any soil amendments are needed before treatment
7. Note any weather-dependent application restrictions
`;
    
                const response = await fetch(GEMINI_URL, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });
    
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error('Gemini API Error:', error);
                return '‚ö†Ô∏è Failed to get AI analysis. Please try again later.';
            } finally {
                loader.style.display = 'none';
            }
        }
    
        function displayAnalysis(text, disease) {
            const container = document.getElementById('ai-analysis-content');
            container.innerHTML = '';
            
            // Extract medicine recommendations if present
            let medicines = [];
            let displayText = text;
            
            try {
                // Look for medicine recommendations marker
                const medStart = text.indexOf('===MEDICINE RECOMMENDATIONS===');
                if (medStart !== -1) {
                    const jsonPart = text.substring(medStart + 30).trim();
                    
                    // Find the first occurrence of { and the last occurrence of }
                    const jsonStart = jsonPart.indexOf('{');
                    const jsonEnd = jsonPart.lastIndexOf('}') + 1;
                    const jsonStr = jsonPart.substring(jsonStart, jsonEnd);
                    
                    medicines = JSON.parse(jsonStr).medicines;
                    displayText = text.substring(0, medStart);
                }
            } catch (e) {
                console.error('Error parsing medicine data:', e);
            }
        
            // Display the analysis text
            const pre = document.createElement('pre');
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.fontFamily = 'inherit';
            pre.textContent = displayText;
            container.appendChild(pre);
            
            // Display medicines if available
            if (medicines.length > 0) {
                displayMedicines(medicines);
            }
        }
        
        function displayMedicines(medicines) {
            const container = document.getElementById('medicine-recommendations') || 
                              document.getElementById('medicine-recommendations-container');
            
            if (!container) {
                console.error('Medicine container not found');
                return;
            }
        
            container.innerHTML = `
                <h3>üíä Recommended Treatments</h3>
                <div class="medicine-grid">
                    ${medicines.map(med => `
                        <div class="medicine-card">
                            <div class="medicine-header">
                                <h4>${med.name}</h4>
                                <span class="medicine-type ${med.type.toLowerCase()}">${med.type}</span>
                            </div>
                            <div class="medicine-details">
                                <p>${med.description}</p>
                                <div class="medicine-specs">
                                    <div><i class="fas fa-flask"></i> Dosage: ${med.dosage}</div>
                                    <div><i class="fas fa-calendar-alt"></i> Frequency: ${med.frequency}</div>
                                </div>
                            </div>
                            <div class="medicine-footer">
                                <span class="medicine-price">${med.price}</span>
                                <button class="buy-button" onclick="searchMedicine('${med.name}')">
                                    <i class="fas fa-search"></i> Find Online
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
    
        function searchMedicine(medicineName) {
            const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(medicineName + ' for plants buy online')}`;
            window.open(searchUrl, '_blank');
        }
    
        // Initialize first stage on load
        window.onload = () => {
            document.getElementById('first-stage').classList.add('active-stage');
        };
    
        // Function to handle second stage initialization
        async function initCropAnalysis() {
            try {
                // Load the second stage model
                const modelURL = TM_MODEL_URL + "model.json";
                const metadataURL = TM_MODEL_URL + "metadata.json";
                model = await tmImage.load(modelURL, metadataURL);
        
                // Reuse the webcam from first stage or create new one
                if (stage1Webcam) {
                    webcam = stage1Webcam;
                    document.getElementById('webcam-container').appendChild(webcam.canvas);
                } else {
                    // If using uploaded image, display it
                    const preview = document.getElementById('upload-preview');
                    if (preview.src) {
                        const img = new Image();
                        img.src = preview.src;
                        await predict(img);
                        return;
                    }
                }
        
                // Start prediction loop
                webcamLoop();
            } catch (error) {
                console.error('Error initializing crop analysis:', error);
                alert('Error initializing crop analysis. Please try again.');
            }
        }function displayClimateData(weatherData, historicalData) {
            const container = document.getElementById('climate-container');
            if (!container) return;
        
            // Calculate averages and trends from historical data
            let climateHTML = '';
            let chartHTML = '';
            
            if (historicalData && historicalData.time && historicalData.time.length > 0) {
                const { temperature_2m_max, temperature_2m_min, precipitation_sum, relative_humidity_2m_mean } = historicalData;
                
                // Calculate 6-month averages
                const avgMaxTemp = temperature_2m_max.reduce((a, b) => a + b, 0) / temperature_2m_max.length;
                const avgMinTemp = temperature_2m_min.reduce((a, b) => a + b, 0) / temperature_2m_min.length;
                const totalPrecip = precipitation_sum.reduce((a, b) => a + b, 0);
                const avgHumidity = relative_humidity_2m_mean.reduce((a, b) => a + b, 0) / relative_humidity_2m_mean.length;
                
                // Calculate trends (last month vs previous 5 months)
                const lastMonthIndex = Math.floor(temperature_2m_max.length * 5/6);
                const lastMonthMaxTemp = temperature_2m_max.slice(lastMonthIndex).reduce((a, b) => a + b, 0) / (temperature_2m_max.length - lastMonthIndex);
                const prevMonthsMaxTemp = temperature_2m_max.slice(0, lastMonthIndex).reduce((a, b) => a + b, 0) / lastMonthIndex;
                
                const tempTrend = lastMonthMaxTemp > prevMonthsMaxTemp ? 'up' : 'down';
                const tempTrendPercentage = Math.abs(((lastMonthMaxTemp - prevMonthsMaxTemp) / prevMonthsMaxTemp) * 100).toFixed(1);
                
                climateHTML = `
                <div class="climate-section">
                    <div class="climate-header">
                        <h2><i class="fas fa-cloud-sun"></i> Climate Analysis</h2>
                        <div class="last-updated">Last updated: ${new Date().toLocaleString()}</div>
                    </div>
                    
                    <div class="climate-cards">
                        <div class="climate-card">
                            <h3><i class="fas fa-temperature-high"></i> Temperature</h3>
                            <div class="climate-value">${weatherData ? weatherData.temp_c.toFixed(1) : '--'}¬∞C</div>
                            <div class="climate-trend">
                                <span>6-month avg: ${avgMaxTemp.toFixed(1)}¬∞C max / ${avgMinTemp.toFixed(1)}¬∞C min</span>
                            </div>
                            <div class="climate-trend">
                                <i class="fas fa-arrow-${tempTrend} ${'trend-' + tempTrend}"></i>
                                <span>${tempTrendPercentage}% ${tempTrend} last month</span>
                            </div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-tint"></i> Humidity</h3>
                            <div class="climate-value">${weatherData ? weatherData.humidity : '--'}%</div>
                            <div class="climate-trend">
                                <span>6-month avg: ${avgHumidity.toFixed(1)}%</span>
                            </div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-cloud-rain"></i> Precipitation</h3>
                            <div class="climate-value">${weatherData ? weatherData.precip_mm.toFixed(1) : '--'}mm</div>
                            <div class="climate-trend">
                                <span>6-month total: ${totalPrecip.toFixed(1)}mm</span>
                            </div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-wind"></i> Wind</h3>
                            <div class="climate-value">${weatherData ? weatherData.wind_kph.toFixed(1) : '--'} km/h</div>
                            <div class="climate-trend">
                                <span>Direction: ${weatherData ? weatherData.wind_dir : '--'}</span>
                            </div>
                        </div>
                    </div>
                    
                    
                        
                `;
            } else {
                climateHTML = `
                <div class="climate-section">
                    <div class="climate-header">
                        <h2><i class="fas fa-cloud-sun"></i> Current Weather</h2>
                    </div>
                    
                    <div class="climate-cards">
                        <div class="climate-card">
                            <h3><i class="fas fa-temperature-high"></i> Temperature</h3>
                            <div class="climate-value">${weatherData ? weatherData.temp_c.toFixed(1) : '--'}¬∞C</div>
                            <div class="climate-unit">Feels like ${weatherData ? weatherData.feelslike_c.toFixed(1) : '--'}¬∞C</div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-tint"></i> Humidity</h3>
                            <div class="climate-value">${weatherData ? weatherData.humidity : '--'}%</div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-cloud-rain"></i> Precipitation</h3>
                            <div class="climate-value">${weatherData ? weatherData.precip_mm.toFixed(1) : '--'}mm</div>
                        </div>
                        
                        <div class="climate-card">
                            <h3><i class="fas fa-wind"></i> Wind</h3>
                            <div class="climate-value">${weatherData ? weatherData.wind_kph.toFixed(1) : '--'} km/h</div>
                            <div class="climate-unit">${weatherData ? weatherData.wind_dir : '--'}</div>
                        </div>
                    </div>
                </div>
                `;
            }
            
            container.innerHTML = climateHTML;
        }
        
        function generateSparkline(maxValues, minValues = null) {
            if (!maxValues || maxValues.length === 0) return '<div class="no-data">No data available</div>';
            
            const allValues = minValues ? [...maxValues, ...minValues] : maxValues;
            const maxVal = Math.max(...allValues);
            const minVal = Math.min(...allValues);
            const range = maxVal - minVal;
            const height = 150;
            
            let points = '';
            let minPoints = '';
            
            // Sample data points to avoid overcrowding
            const step = Math.max(1, Math.floor(maxValues.length / 20));
            
            for (let i = 0; i < maxValues.length; i += step) {
                const x = (i / maxValues.length) * 100;
                const y = height - ((maxValues[i] - minVal) / range) * height;
                points += `${x}% ${y},`;
                
                if (minValues) {
                    const yMin = height - ((minValues[i] - minVal) / range) * height;
                    minPoints += `${x}% ${yMin},`;
                }
            }
            
            if (minValues) {
                return `
                <svg viewBox="0 0 100 ${height}" preserveAspectRatio="none" class="sparkline">
                    <polyline points="${points}" fill="none" stroke="#e74c3c" stroke-width="2"/>
                    <polyline points="${minPoints}" fill="none" stroke="#3498db" stroke-width="2"/>
                    <text x="5" y="15" font-size="10" fill="#e74c3c">Max</text>
                    <text x="5" y="30" font-size="10" fill="#3498db">Min</text>
                </svg>
                `;
            }
            
            return `
            <svg viewBox="0 0 100 ${height}" preserveAspectRatio="none" class="sparkline">
                <polyline points="${points}" fill="none" stroke="#2ecc71" stroke-width="2"/>
            </svg>
            `;
        }
        
        function generateBarChart(values) {
            if (!values || values.length === 0) return '<div class="no-data">No data available</div>';
            
            const maxVal = Math.max(...values);
            const height = 150;
            const barWidth = 100 / values.length;
            
            let bars = '';
            
            // Sample data points to avoid overcrowding
            const step = Math.max(1, Math.floor(values.length / 15));
            
            for (let i = 0; i < values.length; i += step) {
                const barHeight = (values[i] / maxVal) * height;
                const x = (i / values.length) * 100;
                bars += `<rect x="${x}%" y="${height - barHeight}" width="${barWidth}%" height="${barHeight}" fill="#3498db"/>`;
            }
            
            return `
            <svg viewBox="0 0 100 ${height}" preserveAspectRatio="none" class="barchart">
                ${bars}
            </svg>
            `;
        }
        
        function switchTab(tabId, element) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Activate selected tab
            document.getElementById(tabId).classList.add('active');
            element.classList.add('active');
        }
        
        // Update your fetchWeatherData function to call displayClimateData
        async function fetchWeatherData(location) {
            try {
                // Fetch current weather
                const weatherResponse = await fetch(
                    `https://api.weatherapi.com/v1/current.json?key=${WEATHER_API_KEY}&q=${location}&aqi=no`
                );
                const weatherData = await weatherResponse.json();
                
                if (weatherData.error) {
                    console.error('Weather API Error:', weatherData.error.message);
                    return;
                }
                
                // Store current weather data
                this.weatherData = weatherData.current;
                
                // Fetch historical climate data
                const { lat, lon } = weatherData.location;
                const endDate = new Date();
                const startDate = new Date();
                startDate.setMonth(endDate.getMonth() - 6);
                
                const formatDate = (date) => date.toISOString().split('T')[0];
                
                const historicalResponse = await fetch(
                    `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${formatDate(startDate)}&end_date=${formatDate(endDate)}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,relative_humidity_2m_mean&timezone=auto`
                );
                const historicalData = await historicalResponse.json();
                
                if (historicalData.error) {
                    console.error('Historical Climate API Error:', historicalData.error.message);
                    return;
                }
                
                // Store historical climate data
                this.historicalClimateData = historicalData.daily;
                
                // Display all climate data
                displayClimateData(weatherData.current, historicalData.daily);
                
            } catch (error) {
                console.error('Error fetching weather data:', error);
                // Display at least current weather if available
                if (this.weatherData) {
                    displayClimateData(this.weatherData, null);
                }
            }
        }<!-- Only the script part -->
        
        window.addEventListener('DOMContentLoaded', () => {
            const fieldValue = localStorage.getItem('fieldValue'); // Retrieve the stored value
            console.log("‚úÖ Field value from localStorage:", fieldValue);
        
            // Use the field value as needed, e.g., just logging it, no HTML display
            if (fieldValue) {
                console.log("üìå Field selected:", fieldValue);
            } else {
                console.log("‚ùå No field selected.");
            }
        });
    // Helper function to extract plant name from disease name
function getPlantNameFromDisease(diseaseName) {
    if (diseaseName && diseaseName.includes('___')) {
        return diseaseName.split('___')[0].trim();
    }
    return 'Unknown';
}

function saveFarmData() {
    console.log('[DEBUG] Checking data sources:');

    const diseaseElement = document.querySelector('#label-container .result-item strong');
    const diseaseName = diseaseElement?.textContent?.trim() || 'Unknown';
    const diseasePlant = getPlantNameFromDisease(diseaseName);

    let storedField = localStorage.getItem('fieldValue')?.trim() || 'Unknown';
    let storedPlant = localStorage.getItem('plantName')?.trim();

    // Clean up stored plant (remove anything after comma and trim)
    if (storedPlant) {
        storedPlant = storedPlant.split(',')[0].trim();
        if (storedPlant.toLowerCase() === 'unknown') storedPlant = null;
    }

    // Choose final plant name based on disease match
    const finalPlantName = (storedPlant?.toLowerCase() === diseasePlant.toLowerCase())
        ? storedPlant
        : diseasePlant;

    const farmData = {
        timestamp: new Date().toISOString(),
        field: storedField,
        disease: diseaseName,
        plant: finalPlantName,
        soil: {
            nitrogen: parseFloat(document.querySelector('.npk:nth-child(1) .sensor-value')?.textContent) || 0,
            phosphorus: parseFloat(document.querySelector('.npk:nth-child(2) .sensor-value')?.textContent) || 0,
            potassium: parseFloat(document.querySelector('.npk:nth-child(3) .sensor-value')?.textContent) || 0,
            ph: parseFloat(document.querySelector('.ph .sensor-value')?.textContent) || 0,
            moisture: parseFloat(document.querySelector('.moisture .sensor-value')?.textContent) || 0
        },
        weather: this.weatherData || null
    };

    console.log('[DEBUG] Data to be saved:', farmData);

    if (farmData.disease !== 'Unknown' || farmData.soil.nitrogen > 0) {
        let history = JSON.parse(localStorage.getItem('farmHistory')) || [];
        history.push(farmData);
        localStorage.setItem('farmHistory', JSON.stringify(history));
        console.log('‚úÖ Data saved');
    } else {
        console.warn('‚ö†Ô∏è Not saving - no valid data detected');
    }

    return farmData;
}function sendLatestFarmData() {
    // Optional: Call your function that updates the DOM before reading values
    if (typeof updateSensorDisplayFromSource === 'function') {
        updateSensorDisplayFromSource();
    }

    // Clear any previous cached data to avoid confusion
    localStorage.removeItem('farmDataTemp');

    setTimeout(() => {
        const farmData = saveFarmData(); // Must return fresh object from live DOM
        localStorage.setItem('farmDataTemp', JSON.stringify(farmData));
        console.log('‚úÖ Latest farmData saved to localStorage:', farmData);
    }, 300); // Adjust delay  if your DOM takes more time to update
}
// ======================== DATA COLLECTION & FLASK COMMUNICATION =======================

/**
 * Gets the ID token from localStorage
 */
/**
 * Gets the ID token from localStorage and stores it in idToken variable
 * @returns {string|null} The ID token or null if not found
 */
function getAndStoreIdToken() {
    try {
        const idToken = localStorage.getItem('idToken');
        if (!idToken) {
            console.warn("No ID token found in localStorage");
            return null;
        }
        
        // Basic validation (check if it looks like a JWT)
        if (idToken.split('.').length !== 3) {
            console.warn("Invalid token format - clearing");
            localStorage.removeItem('idToken');
            return null;
        }
        
        return idToken;
    } catch (error) {
        console.error("Error accessing token:", error);
        return null;
    }
}

// Usage:

/**
 * Checks if all required data is loaded on the page
 */
function isDataLoaded() {
    // Check if disease prediction is loaded
    const diseaseElement = document.querySelector('#label-container .result-item strong');
    if (!diseaseElement?.textContent?.trim()) {
        console.log('Waiting for disease prediction to load...');
        return false;
    }

    // Check if sensor data is loaded
    const sensorValues = [
        document.querySelector('.npk:nth-child(1) .sensor-value')?.textContent,
        document.querySelector('.npk:nth-child(2) .sensor-value')?.textContent,
        document.querySelector('.npk:nth-child(3) .sensor-value')?.textContent,
        document.querySelector('.ph .sensor-value')?.textContent,
        document.querySelector('.moisture .sensor-value')?.textContent
    ];

    if (sensorValues.some(val => !val || val.trim() === '0')) {
        console.log('Waiting for sensor data to load...');
        return false;
    }

    // Check if AI analysis is loaded
    if (!document.getElementById('ai-analysis-content')?.textContent) {
        console.log('Waiting for AI analysis to load...');
        return false;
    }

    // Check if medicines are loaded
    const medicineCards = document.querySelectorAll('.medicine-card');
    if (medicineCards.length === 0) {
        console.log('Waiting for medicine recommendations to load...');
        return false;
    }

    return true;
}

/**
 * Collects all relevant data from the page and localStorage
 */
async function collectAllData() {
    // Wait until all data is loaded
    await waitForDataLoad();
    
    // Get disease prediction
    const diseaseElement = document.querySelector('#label-container .result-item strong');
    const diseaseName = diseaseElement?.textContent?.trim() || 'Unknown';
    
    // Get sensor data (NPK, pH, moisture)
    const sensorData = {
        nitrogen: parseFloat(document.querySelector('.npk:nth-child(1) .sensor-value')?.textContent) || 0,
        phosphorus: parseFloat(document.querySelector('.npk:nth-child(2) .sensor-value')?.textContent) || 0,
        potassium: parseFloat(document.querySelector('.npk:nth-child(3) .sensor-value')?.textContent) || 0,
        ph: parseFloat(document.querySelector('.ph .sensor-value')?.textContent) || 0,
        moisture: parseFloat(document.querySelector('.moisture .sensor-value')?.textContent) || 0,
        timestamp: new Date().toISOString()
    };
    
    // Get AI analysis text
    const aiAnalysis = document.getElementById('ai-analysis-content')?.textContent || '';
    
    // Get medicine recommendations
    const medicineElements = document.querySelectorAll('.medicine-card');
    const medicines = Array.from(medicineElements).map(med => ({
        name: med.querySelector('h4')?.textContent || 'Unknown',
        type: med.querySelector('.medicine-type')?.textContent || 'Unknown',
        dosage: med.querySelector('.medicine-specs div:nth-child(1)')?.textContent.replace('Dosage: ', '') || '',
        frequency: med.querySelector('.medicine-specs div:nth-child(2)')?.textContent.replace('Frequency: ', '') || '',
        description: med.querySelector('.medicine-details p')?.textContent || ''
    }));
    
    // Get location data from localStorage
    const locationData = {
        district: localStorage.getItem('district') || 'Unknown',
        village: localStorage.getItem('village') || 'Unknown',
        field: localStorage.getItem('fieldValue') || 'Unknown',
        plant: localStorage.getItem('plantName') || 'Unknown'
    };


    
 // Prepare the complete data object
const allData = {
    timestamp: new Date().toISOString(),
    disease: diseaseName,
    sensor_data: sensorData,
    climate_data: this.weatherData || null,
    historical_climate: this.historicalClimateData || null,
    ai_analysis: aiAnalysis,
    medicines: medicines,
    location: locationData,

    // ‚úÖ Added field data
    all_fields: JSON.parse(localStorage.getItem('fields')) || [],
    selected_field: (() => {
        const selectedId = parseInt(localStorage.getItem('selectedField'));
        const fields = JSON.parse(localStorage.getItem('fields')) || [];
        return fields.find(f => f.id === selectedId) || null;
    })()
};

    console.log('Collected data:', allData);
    return allData;
}

/**
 * Waits until all required data is loaded on the page
 */
async function waitForDataLoad(maxAttempts = 10, interval = 1000) {
    let attempts = 0;
    
    return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
            attempts++;
            
            if (isDataLoaded()) {
                clearInterval(checkInterval);
                resolve();
            } else if (attempts >= maxAttempts) {
                clearInterval(checkInterval);
                reject(new Error('Data loading timed out'));
            }
        }, interval);
    });
}

/**
 * Sends collected data to Flask endpoint with ID token from localStorage
 */
async function sendDataToFlask() {
    try {
        console.log('Starting data collection and transmission...');
        const dataToSend = await collectAllData();
        const idToken = getAndStoreIdToken();
        
        
        // Replace with your actual Flask endpoint URL
        const flaskEndpoint = 'http://localhost:5000/webhook/user_data';
        
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };
        
        // Add Authorization header only if token exists
        if (idToken) {
            headers['Authorization'] = `Bearer ${idToken}`;
        }
        
        console.log('Sending data to Flask endpoint...');
        const response = await fetch(flaskEndpoint, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(dataToSend),
            mode: 'cors'
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('Successfully sent to Flask:', result);
        return result;
    } catch (error) {
        console.error('Failed to send to Flask:', error);
        
        // Fallback: Save data to localStorage if sending fails
        try {
            const failedData = JSON.parse(localStorage.getItem('failedFlaskSubmissions') || '[]');
            failedData.push(await collectAllData());
            localStorage.setItem('failedFlaskSubmissions', JSON.stringify(failedData));
            console.log('Data saved to localStorage for later retry');
        } catch (storageError) {
            console.error('Failed to save data to localStorage:', storageError);
        }
        
        throw error;
    }
}

/**
 * Attempts to send any previously failed submissions using ID token from localStorage
 */
async function retryFailedSubmissions() {
    const failedData = JSON.parse(localStorage.getItem('failedFlaskSubmissions') || '[]');
    if (failedData.length === 0) {
        console.log('No failed submissions to retry');
        return;
    }
    
    console.log(`Retrying ${failedData.length} failed submissions...`);
    
    const idToken = getAndStoreIdToken();
    const headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    };
    
    if (idToken) {
        headers['Authorization'] = `Bearer ${idToken}`;
    }
    
    const remainingFailures = [];
    
    for (const data of failedData) {
        try {
            const response = await fetch('http://localhost:5000/webhook/user_data', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(data),
                mode: 'cors'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            console.log('Successfully resent data:', data.timestamp);
        } catch (error) {
            console.error('Failed to resend data:', error);
            remainingFailures.push(data);
        }
    }
    
    localStorage.setItem('failedFlaskSubmissions', JSON.stringify(remainingFailures));
    if (remainingFailures.length > 0) {
        console.log(`${remainingFailures.length} submissions still failed and will be retried later`);
    }
}

// Event listener that triggers when the page is fully loaded
document.addEventListener('DOMContentLoaded', function() {
    // You can trigger this manually when needed or set up automatic triggers
    console.log('DOM fully loaded and parsed');
    
    // Example: Send data when a button is clicked
    const sendDataButton = document.getElementById('send-data-button');
    if (sendDataButton) {
        sendDataButton.addEventListener('click', async function() {
            try {
                await sendDataToFlask();
                alert('Data successfully sent!');
            } catch (error) {
                alert('Failed to send data. It will be saved for later retry.');
            }
        });
    }
    
    // Alternatively, automatically send data when all elements are ready
    const autoSendData = true; // Set to false if you want manual control
    
    if (autoSendData) {
        // Wait an additional second to ensure all dynamic content is loaded
        setTimeout(async () => {
            try {
                await sendDataToFlask();
                console.log('Data automatically sent successfully');
            } catch (error) {
                console.log('Automatic data send failed, will retry later');
            }
            
            // Also try to send any previously failed submissions
            await retryFailedSubmissions();
        }, 1000);
    }
});
// language.js - Put this in a shared file and include in all HTML files
// Language configuration
const languageConfig = {
    'en': { name: 'English', direction: 'ltr' },
    'ta': { name: 'Tamil', direction: 'ltr' },
    'te': { name: 'Telugu', direction: 'ltr' }
};

// Initialize language
function initLanguage() {
    // Get stored language or default to English
    const langCode = localStorage.getItem('selectedLanguage') || 'en';
    applyLanguage(langCode);
    
    // Setup Google Translate
    initGoogleTranslate(langCode);
}

function applyLanguage(langCode) {
    document.documentElement.lang = langCode;
    document.documentElement.dir = languageConfig[langCode]?.direction || 'ltr';
}

function initGoogleTranslate(defaultLang) {
    // First, set the Google Translate cookie to force the language
    if (defaultLang && defaultLang !== 'en') {
        document.cookie = `googtrans=/en/${defaultLang}; path=/; expires=${new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toUTCString()}`;
    }

    // Create the Google Translate script if it doesn't exist
    if (!window.google || !window.google.translate) {
        const script = document.createElement('script');
        script.src = 'https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit';
        document.head.appendChild(script);
        
        window.googleTranslateElementInit = function() {
            new google.translate.TranslateElement({
                pageLanguage: 'en',
                includedLanguages: 'en,ta,te',
                layout: google.translate.TranslateElement.InlineLayout.SIMPLE,
                autoDisplay: false
            }, 'google_translate_element');
            
            // Hide the Google Translate branding
            const googleBranding = document.querySelector('.goog-te-banner-frame');
            if (googleBranding) {
                googleBranding.style.display = 'none';
            }
            
            // Force the language selection
            if (defaultLang && defaultLang !== 'en') {
                setTimeout(() => {
                    const select = document.querySelector('.goog-te-combo');
                    if (select) {
                        select.value = defaultLang;
                        select.dispatchEvent(new Event('change'));
                    }
                }, 1000);
            }
        };
    } else {
        googleTranslateElementInit();
    }
}

// Track language changes
function trackLanguageChanges() {
    setInterval(() => {
        const iframe = document.querySelector('.goog-te-menu-frame');
        if (iframe) {
            iframe.contentDocument.querySelector('.goog-te-menu2-item').addEventListener('click', function() {
                const lang = this.getAttribute('data-language');
                localStorage.setItem('selectedLanguage', lang);
                applyLanguage(lang);
            });
        }
    }, 1000);
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initLanguage();
    trackLanguageChanges();
});
 </script>
        
       
        
    
</body>
</html>